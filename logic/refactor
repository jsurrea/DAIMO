# parameters



    ## Parameters
    arcos = list()
    municipios = []
    pares_origen_destino = []
    vehiculos = ["Autos", "Buses", "C-2", "C-3-4", "C-5", ">C-5"]
    costo_transitar_arco = {} 
    arcos_por_municipio = {} 

    # inicializar los arcos para cada municipio en una lista
    for m in municipios:
        arcos_por_municipio[m] = list()


        if str(linea[0])[0] == "0":  # CODIGOVIA
            municipio = str(linea[0])[1:]
        else:
            municipio = str(linea[0])

        # Identificar los arcos y nodos en los municipios
        if linea[7] == "Vía Municipal" and municipio in municipios:  # CLASE_DE_R
            arcos_por_municipio[municipio].append((inicio, final))
            arcos_por_municipio[municipio].append((final, inicio))
            if not municipio in nodos_por_municipio:
                nodos_por_municipio[municipio] = inicio

    #Asignar nodo interno del municipio si hay
    for m in municipios:
        nodos_local = []
        for i in arcos_por_municipio[m]:
            nodos_local.append(i[0])
        for i in nodos_local:
            if nodos_local.count(i)>1:
                nodos_por_municipio[m] = i


    #Creación grafo
    G = nx.Graph()
    for i,j in arcos:
        G.add_edge(i, j, weightC2=costo_transitar_arco["C-2",i,j], weightC34=costo_transitar_arco["C-3-4",i,j], weightC5=costo_transitar_arco["C-5",i,j], weightCmas5=costo_transitar_arco[">C-5",i,j])


    
    # Save as pickle files
    pkl_path = path.join("resources", "pickles")
    pickle.dump(G, open(path.join(pkl_path, "G.pkl"), 'wb'))


# costs


    costoExcedente = {}
    ODVxPuente = {puente: [] for puente in puentes}
    arco2puente = model.rutas_por_puente()
    
    total_cost_params = {
        "arco2puente": arco2puente,
        "ODVxPuente": ODVxPuente,
        "costoExcedente": costoExcedente,
    }

    # Costo original
    costoTotal = model.calculate_weighted_distances(demanda_arco, total_cost_params)
    costos = {"TOTAL": (costoTotal,0)}
    model.costos = costos
    print("Costo original:", costoTotal)

    # Alternativa con el puente
    for puente in tqdm(puentes):
        costos[puente] = model.calculate_cost([puente])
        print(puente, costos[puente])
    print("Costos calculados:", costos, sep="\n")


    # Save pickles
    pkl_path = path.join("resources", "pickles")
    pickle.dump(arco2puente, open(path.join(pkl_path, "arco2puente.pkl"), 'wb'))
    pickle.dump(ODVxPuente, open(path.join(pkl_path, "ODVxPuente.pkl"), 'wb'))
    pickle.dump(costoExcedente, open(path.join(pkl_path, "costoExcedente.pkl"), 'wb'))
    pickle.dump(costos, open(path.join(pkl_path, "costos.pkl"), 'wb'))
    

# model


    # TODO CAMBIAR axp por dict con 1 puente -> 1 arco
        # Load parameters
        self.costos = pickle.load(open(path.join(pkl_path, "costos.pkl"), "rb"))
        self.costoExcedente = pickle.load(open(path.join(pkl_path, "costoExcedente.pkl"), "rb"))
        self.ODVxPuente = pickle.load(open(path.join(pkl_path, "ODVxPuente.pkl"), "rb"))
        self.arco2puente = pickle.load(open(path.join(pkl_path, "arco2puente.pkl"), "rb"))
        
        

        

    def calculate_cost(self, puentes):

        self.load_parameters()
        self.load_costs()

        puentes = set(puentes)

        costoAlternativa = self.costos["TOTAL"][0]
        ODVs = set()

        edge_data = {}
        for puente in puentes:
            arcos = self.axp[puente]
            for i,j in arcos:
                if self.G.has_edge(i,j):
                    edge_data[i,j] = self.G.get_edge_data(i,j)
                    self.G.remove_edge(i,j)
            ODVs |= set(self.ODVxPuente[puente])
        costoExcedente = sum(self.costoExcedente[odv] for odv in ODVs)
        costoAlternativa -= costoExcedente
        costoAlternativa += self.calculate_weighted_distances(ODVs)
        deltaCosto = costoAlternativa - self.costos["TOTAL"][0]

        for i,j in edge_data.keys():
            self.G.add_edge(i,j, **edge_data[i,j])

        return costoAlternativa, deltaCosto
    

    # def calculate_weighted_distances(self, odv, total_cost_params = None):

    #     costo_calculado = 0

    #     for origen,destino,veh in odv:

    #         #Nodo inicio y fin
    #         s = self.nodos_por_municipio[origen]
    #         t = self.nodos_por_municipio[destino]

    #         distance, path = nx.single_source_dijkstra(self.G, source=s, target=t, weight=veh)
    #         distance *= self.demanda_arco[origen,destino,veh]
    #         costo_calculado += distance

    # YA ESTA BIEN COSTO TOTAL
            
            if total_cost_params:
                
                for i in range(1, len(path)):
                    arco = (path[i-1], path[i])
                    if arco in total_cost_params["arco2puente"]:
                        puente = total_cost_params["arco2puente"][arco]
                        total_cost_params["ODVxPuente"][puente].append((origen,destino,veh))
                        total_cost_params["costoExcedente"][(origen,destino,veh)] = distance
                        
        # if total_cost_params:
        #     self.arco2puente = total_cost_params["arco2puente"]
        #     self.ODVxPuente = total_cost_params["ODVxPuente"]
        #     self.costoExcedente = total_cost_params["costoExcedente"]
            
        return costo_calculado
    
